### Knowledge base - task description ###

Webサーバにおいて、より多くのオプショナルコンテンツが提供されたり、システムの負荷を減らしてレスポンス時間の要件が満たされたりすれば、収益は高くなります。
オプショナルコンテンツを提供しなければ、システムの負荷は減ります。
さらに、サーバの数を増やせばシステムの負荷は減るが、システムの運用コストはサーバの数に比例して大きくなってしまいます。










### Knowledge base - adaptation goal ###

SWIM環境でシステムをシミュレーションする際、パラメータで定義された期間の中で、AdaptationManagerがevaluate()メソッドを呼び出し、これらのトレードオフを扱います。
オプショナルコンテンツが付くか付かないかどうかは[0..1]をとるdimmerという値によって確率的に決まります。また、この期間内でのutilityの値を外部で定められた効用関数によって決定し、
シミュレーションの全期間のutilityの和を最大化することを目標とします。

効用関数はR言語で書かれていて、以下のようなプログラムです。

periodUtilitySEAMS2017A <- function(maxServers, maxServiceRate, arrivalRateMean, dimmer,
                                  evaluationPeriod, RT_THRESHOLD, avgResponseTime,
                                  avgServers) {
  basicRevenue <- 1
  optRevenue <- 1.5
  serverCost <- 10
  
  precision <- 1e-5
  
  maxThroughput <- maxServers * maxServiceRate

  Ur <- (arrivalRateMean * ((1 - dimmer) * basicRevenue + dimmer * optRevenue))
  Uc <- serverCost * (maxServers - avgServers)
  UrOpt <- arrivalRateMean * optRevenue
  
  utility <- ifelse(avgResponseTime <= RT_THRESHOLD & Ur >= UrOpt - precision, Ur + Uc,
                    ifelse(avgResponseTime <= RT_THRESHOLD, Ur,
                           pmin(0.0, arrivalRateMean - maxThroughput) * optRevenue))
}











### Knowledge base - variable information ###

dimmer値の調整やサーバーの数の変更は、pMacroTactic->addTactic()によって実現されます。
サーバーを増やすとき:       pMacroTactic->addTactic(new AddServerTactic);
dimmerの値を更新するとき:   pMacroTactic->addTactic(new SetDimmerTactic(dimmer))
サーバーを減らすとき:       pMacroTactic->addTactic(new RemoveServerTactic)

evaluate()メソッドはMacroTaticを返す。これらのTacticは並行して実行されるため、すべての操作を並列して行うことができる。

また、サーバーを増やしてから起動するまでには時間を必要とするため、Serverの数とactiveServerの数は異なる。
Serverの数は効用にあまり効果を及ぼさず、activeServerの数が重要だが、起動中のサーバーがあるかどうかを考慮する必要がある。

以上を踏まえた上で、既存のAdaptationManagerのプログラムを教えます。



ReactiveAdaptationManager.h

#ifndef __PLASASIM_REACTIVEADAPTATIONMANAGER_H_
#define __PLASASIM_REACTIVEADAPTATIONMANAGER_H_

#include "BaseAdaptationManager.h"

/**
 * Simple reactive adaptation manager
 */
class ReactiveAdaptationManager : public BaseAdaptationManager
{
  protected:
    virtual Tactic* evaluate();
};

#endif



ReactiveAdaptationManager.cpp

#include "ReactiveAdaptationManager.h"
#include "managers/adaptation/UtilityScorer.h"
#include "managers/execution/AllTactics.h"

using namespace std;

Define_Module(ReactiveAdaptationManager);

Tactic* ReactiveAdaptationManager::evaluate() {
    MacroTactic* pMacroTactic = new MacroTactic;
    Model* pModel = getModel();
    const double dimmerStep = 1.0 / (pModel->getNumberOfDimmerLevels() - 1);
    double dimmer = pModel->getDimmerFactor();
    double spareUtilization =  pModel->getConfiguration().getActiveServers() - pModel->getObservations().utilization;
    bool isServerBooting = pModel->getServers() > pModel->getActiveServers();
    double responseTime = pModel->getObservations().avgResponseTime;

    if (responseTime > RT_THRESHOLD) {
        if (!isServerBooting
                && pModel->getServers() < pModel->getMaxServers()) {
            pMacroTactic->addTactic(new AddServerTactic);
        } else if (dimmer > 0.0) {
            dimmer = max(0.0, dimmer - dimmerStep);
            pMacroTactic->addTactic(new SetDimmerTactic(dimmer));
        }
    } else if (responseTime < RT_THRESHOLD) { // can we increase dimmer or remove servers?

        // only if there is more than one server of spare capacity
        if (spareUtilization > 1) {
            if (dimmer < 1.0) {
                dimmer = min(1.0, dimmer + dimmerStep);
                pMacroTactic->addTactic(new SetDimmerTactic(dimmer));
            } else if (!isServerBooting
                    && pModel->getServers() > 1) {
                pMacroTactic->addTactic(new RemoveServerTactic);
            }
        }
    }

    return pMacroTactic;
}


Define_Module()は必ず明記しましょう。





次に関連するプログラムについて情報を提供します。

model.h

#ifndef MODEL_H_
#define MODEL_H_

#include <omnetpp.h>
#include <set>
#include "Configuration.h"
#include "Environment.h"
#include "Observations.h"

class Model : public omnetpp::cSimpleModule {
public:

    /*
     * there are some methods (e.g., removeExpectedChange() that do not check
     * the type of change, so if a new change type is added, those methods
     * would have to be fixed
     */
    enum ModelChange { SERVER_ONLINE};

    struct ModelChangeEvent {
        double startTime; // when the event was created
        double time; // when the event will happen
        ModelChange change;
    };

    struct ModelChangeEventComp {
      bool operator() (const ModelChangeEvent& lhs, const ModelChangeEvent& rhs) const {
          return lhs.time < rhs.time;
      }
    };
    typedef std::multiset<ModelChangeEvent, ModelChangeEventComp> ModelChangeEvents;

protected:
    static const char* HORIZON_PAR;
    virtual int numInitStages() const {return 2;}
    virtual void initialize(int stage);

    ModelChangeEvents events;


    // these are used so that we can query the model for what happened an instant earlier
    // TODO save the configuration using a timestamp
    int activeServerCountLast;
    double timeActiveServerCountLast;


    double evaluationPeriod;
    double dimmerMargin; /**< the used range for the dimmer is [dimmerMargin, 1-dimmerMargin] */
    bool lowerDimmerMargin = false;


    // these hold the current configuration, plus the events for the booting server
    int activeServers; /**< number of active servers (there is one more powered up if a server is booting) */
    double brownoutFactor;

    Environment environment;
    Observations observations;
    int maxServers;
    double bootDelay;
    int horizon;
    int serverThreads;
    double serviceTime;
    double serviceTimeVariance;
    double lowFidelityServiceTime;
    double lowFidelityServiceTimeVariance;
    int numberOfBrownoutLevels;

    void addExpectedChange(double time, ModelChange change);

    /**
     * This method removes the last expected change (scheduled farthest in the future)
     * For generality, addExpectedChange() should return some id that could be
     * then used to remove the event.
     */
    void removeExpectedChange();

    bool isServerBooting() const;

public:
    Model();


    /* the following methods are less general */

    /**
     * Returns the expected number of active servers at a time in the future
     */
    int getActiveServerCountIn(double deltaTime);
    int const getActiveServers() const;
    int const getServers() const;

    void addServer(double bootDelay);
    void serverBecameActive();
    void removeServer();

    Configuration getConfiguration();
    const Environment& getEnvironment() const;
    virtual void setEnvironment(const Environment& environment);
    const Observations& getObservations() const;
    void setObservations(const Observations& observations);
    int getMaxServers() const;
    double getEvaluationPeriod() const;
    double getBootDelay() const;
    int getHorizon() const;

    double getLowFidelityServiceTime() const;
    void setLowFidelityServiceTime(double lowFidelityServiceTimeMean, double lowFidelityServiceTimeVariance);
    int getServerThreads() const;
    void setServerThreads(int serverThreads);
    double getServiceTime() const;
    void setServiceTime(double serviceTimeMean, double serviceTimeVariance);

    double getLowFidelityServiceTimeVariance() const;
    double getServiceTimeVariance() const;

    void setDimmerFactor(double factor);
    double getDimmerFactor() const;

    /**
     * Returns true if dimmer margin is only used at the bottom of the range
     */
    bool isDimmerMarginLower() const;

    int getNumberOfDimmerLevels() const;
    double dimmerLevelToFactor(int dimmerLevel) const;
    int dimmerFactorToLevel(double dimmerFactor) const;

    // brownout is the complement of dimmer
    void setBrownoutFactor(double factor);
    double getBrownoutFactor() const;

    int getNumberOfBrownoutLevels() const;
    double brownoutLevelToFactor(int brownoutLevel) const;
    int brownoutFactorToLevel(double brownoutFactor) const;

    double getDimmerMargin() const;

    virtual ~Model();
};

#endif /* MODEL_H_ */






Observations.h

#ifndef OBSERVATIONS_H_
#define OBSERVATIONS_H_

class Observations {
public:
    double basicResponseTime;
    double optResponseTime;
    double basicThroughput;
    double optThroughput;
    double avgResponseTime;
    double utilization;

    Observations();
};

#endif /* OBSERVATIONS_H_ */





BaseAdaptationManager.h

#ifndef __PLASA_BASEADAPTATIONMANAGER_H_
#define __PLASA_BASEADAPTATIONMANAGER_H_

#include <omnetpp.h>
#include "model/Model.h"
#include "managers/execution/Tactic.h"

/**
 * Base class for all adaptation manager modules
 */
class BaseAdaptationManager : public omnetpp::cSimpleModule
{
    omnetpp::simsignal_t decisionTimeSignal;
    Model* pModel;

protected:
    omnetpp::cMessage *periodEvent; // pointer to the event object which we'll use for timing
    omnetpp::cMessage *decisionCompleteEvent; // event for notifying of decision completion
  Tactic* pTactic;

  virtual int numInitStages() const {return 2;}
  virtual void initialize(int stage);
  virtual void handleMessage(omnetpp::cMessage *msg);

  /**
   * Dispatches the execution of the result of the decision
   */
  virtual void decisionComplete();

  inline Model* getModel() { return pModel; }

  /**
   * Adaptation decision implementation
   *
   * @return Tactic* (possibly a MacroTactic*) or null if none must be executed.
   *   Deletion of the tactic object is done by the caller of this method.
   */
  virtual Tactic* evaluate() = 0;

public:
  BaseAdaptationManager();
  virtual ~BaseAdaptationManager();
};

#endif



utility.h

#ifndef UTILITYSCORER_H_
#define UTILITYSCORER_H_
#include <model/Configuration.h>
#include <model/Environment.h>
#include <model/Observations.h>
#include <model/Model.h>

#define RT_THRESHOLD omnetpp::getSimulation()->getSystemModule()->par("responseTimeThreshold").doubleValue()

/*
 * MAX_SERVICE_RATE is the max number of requests/sec a single server can
 * process with normal service.
 */
#define MAX_SERVICE_RATE omnetpp::getSimulation()->getSystemModule()->par("maxServiceRate").doubleValue()

class UtilityScorer {
protected:
    UtilityScorer() {}; // no instances

    static const char* OPT_REVENUE;
    static const char* PENALTY_MULTIPLIER;

public:

    /**
     * Computes utility accrued
     */
    static double getAccruedUtility(const Model& model, const Configuration& configuration, const Environment& environment, const Observations& observations);
};

#endif /* UTILITYSCORER_H_ */










### Knowledge base - taskdescription & adaptation goal & variable information ###
あなたは、これらのトレードオフをより良く扱えて、効用関数periodUtilitySEAMS2017Aによって求められるutilityの和が大きくなるであろう新しいルールを考えてください。
様々なメトリクスを線型結合したり二次形式にしたりしてメトリクスを複合的に組み合わせることも出来ます。

そして、MyReactiveAdaptationManager.cppのevaluateメソッドを下記の制約のもと実装してください。


制約1:
システムのシミュレーションにおいて使用できるメトリクスと、メトリクスを得るために必要なメソッドは以下の通りです。

pModel->getObservations().basicResponseTime     : the average response time for basic responses not including optional content
pModel->getObservations().optResponseTime       : the average response time for responses with optional content
pModel->getObservations().basicThroughput       : the throughput for basic responses not including optional content
pModel->getObservations().optThroughput         : the throughput for responses with optional content
pModel->getObservations().avgResponseTime       : the average response time for responses including and not optional content
pModel->getObservations().utilization           : the utilization of the server with serverId
pModel->getConfiguration().getActiveServers()   : the number of active servers
pModel->getDimmerFactor()                       : the dimmer value
pModel->getServers()                            : the number of servers
pModel->getActiveServers()                      : the number of active servers
pModel->getMaxServers()                         : the maximum number of servers

サーバーが起動中かどうかは　pModel->getServers() > pModel->getConfiguration().getActiveServers()で確認して下さい。

ここに示した以外のメトリクスを使いたければ、先ほど提示したmodel.hやobservations.hを参照してください。


制約2:
/managers/adaptation/UtilityScorer.hをincludeすれば、マクロ変数RT_THRESHOLDはレスポンス時間の閾値として定義されているので使用可能です。
RT_THRESHOLDではない他のマクロ変数を使用する場合はプログラムの冒頭にあなたが定義してから使用してください。

制約3:
ディレクトリ構造について。
~/swim/swim/src/
    managaers/
        adaptation/
            UtilityScorer.h
            BaseAdaptationManager.h
            MyReactiveAdaptation.h
            MyReactiveAdaptation.cc
        execution/
            AllTactics.h
    model/
        Configuration.h
        Model.h
        Observtions.h

クラスTacticに関連するファイルは"managers/execution/AllTactics.h"をincludeすれば事足りる。

MacroTacticは並行して複数の操作を行うことができるため、MacroTactic内にサーバーの数を扱う操作を複数回実行しようとするときは、サーバーの数の上限と下限に注意して、
つまりactiveサーバーが1つしかない時に２回RemoveServerTacticを実行したり、サーバーの数の上限MaxServersを超えてサーバーの数を増やそうとしないことに気をつけて、
上記3つの制約を絶対に守って、プログラムを実装してください。




###ここで初めて実装させる###









###以下更新フェーズ###


### １回目 ###

### Analyzer ###
シミュレーション結果は、
時間(Time), 平均応答時間(avgResponseTime),サーバーの数(Servers),activeサーバーの数(ActiveServers),Dimmer(Dimmer),時間に対応する効用関数の値(Utility)
の関係がスペース区切りの表形式で与えられます。

一般に、サーバーを取り除いたり、dimmer値を大きくすれば効用が上がります。しかし、サーバーの数を増やしたりdimmer値を低くしたら、レスポンス時間が短くなることで、効用が上がります。
つまり、dimmerは大きく、サーバーの数は少ない方が好ましいが、dimmerを小さくしてサーバーの数を増やすことでレスポンス時間を短くできる、ということです。

これらの方針は
pMacroTactic->addTactic()によって実現されます。
サーバーを増やすとき:       pMacroTactic->addTactic(new AddServerTactic);
dimmerの値を更新するとき:   pMacroTactic->addTactic(new SetDimmerTactic(dimmer))
サーバーを減らすとき:       pMacroTactic->addTactic(new RemoveServerTactic)


今回実装していただいたevaluationメソッド



[PROG]




でのシミュレーションの結果、utilityの合計値は [UTILITY] でした。
utilityの合計値を大きくすることを目標に、新しいMyAdaptationManage::evaluate()を実装してください。


結果を提供します。
[CSV]



### CoT ###

1.結果を見るとどの時間帯にutilityが低くなっているか一箇所選んでください。


2.その時間帯に低いutilityになってしまった原因はなんでしょうか。


3.その原因を引き起こしてしまったevaluationメソッドでのルール設計において一番大きな問題は何でしょうか。


4.コードで特定するとどの箇所になるでしょうか。


5.その部分の改善方針と、そのように改善する理由を教えてください。


6.それを踏まえてevaluationメソッドを実装してみましょう。



















### 更新２回目以降###

### Analyzer ###
### add information about hostorical program and best program ###
過去 [xxxx] 個の実装していただいたevaluationメソッドとそのプログラムを改善する点は古い順に

[PROG]
[RECONSIDERATION]

[PROG]
[RECONSIDERATION]

[PROG]
[RECONSIDERATION]

[PROG]
[RECONSIDERATION]

[PROG]
[RECONSIDERATION]



utilityの合計値が最も高かったプログラムは
[PROG]

その改善点は
[RECONSIDERATION]

シミュレーション結果のutilityの合計値は [UTILITY] でした。




実装していただいた最新のプログラムでのシミュレーションの結果、utilityの合計値は [UTILITY] でした。

また、各時間との関係は以下のようになりました。
[CSV]



### Planner ###
utilityの値の合計値を大きくすることを目標とした新しいMyAdaptationManage::evaluate()の改善の参考にして下さい。

1.
throghputが大きい時やResponseTimeが短い時にサーバーがたくさん起動している時は、コストが余計にかかってしまっている可能性があるのでサーバーの数を減らすとさらに改善するかもしれません。

2.
メトリクスを複合的に組み合わせていますか。線型結合や二次形式など様々な組み合わせ方があります。
もし複合的に組み合わせていたら、閾値を変えてみたり、メトリクスの重みを変えてみたりしてみましょう。

3.
使用可能なのに使っていないメトリクスがあれば使ってみましょう。

4.
複数のTactic操作を並行して行えることに注目しましょう。

例えば以下のようなプログラムがあったとき、


Tactic* ExampleAdaptationManager::evaluate() {
    MacroTactic* pMacroTactic = new MacroTactic;
    Model* pModel = getModel();
    const double dimmerStep = 1.0 / (pModel->getNumberOfDimmerLevels() - 1);
    double dimmer = pModel->getDimmerFactor();
    double spareUtilization =  pModel->getConfiguration().getActiveServers() - pModel->getObservations().utilization;
    bool isServerBooting = pModel->getServers() > pModel->getActiveServers();
    double responseTime = pModel->getObservations().avgResponseTime;

    if (responseTime > RT_THRESHOLD) {
        if (!isServerBooting
                && pModel->getServers() < pModel->getMaxServers()) {
            pMacroTactic->addTactic(new AddServerTactic);
            if (dimmer > 0.0) {
                dimmer = max(0.0, dimmer - dimmerStep);
                pMacroTactic->addTactic(new SetDimmerTactic(dimmer));
            }
        }
    }
    return pMacroTactic;
}

response時間が閾値より大きく、サーバーが起動中ではなく、dimmer値が0より大きい場合にevaluateメソッドは
MacroTactic = [AddServerTactic(), SetDimmerTactic()]
を返します。

つまり、サーバーの数の変更とdimmer値の調整を一回の操作でできるということです。

逆の状況でも、
MacroTactic = [RemoveServerTactic(), SetDimmerTactic()] を返すことができれば、サーバーを減らしつつdimmerの調整ができて効率よくutilityを調整できると思います。




### CoT ###

1.最新の結果を見るとどの時間帯にutilityが低くなっているか一箇所選んでください。


2.その時間帯に低いutilityになってしまった原因はなんでしょうか。


3.その原因を引き起こしてしまったevaluationメソッドでのルール設計において一番大きな問題は何でしょうか。


4.コードで特定するとどの箇所になるでしょうか。


5.その部分の改善方針と、そのように改善する理由を教えてください。


6.それを踏まえてevaluationメソッドを実装してみましょう。